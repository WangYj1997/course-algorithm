# 第2章 排序算法

## 2.1 冒泡排序

时间复杂度 $$O(N^2)$$

``` cpp
void bubble_sort (int arr[], int len) {
    for (int i=0; i<len-1; i++) {       
        for (int j=0; j<len-1-i; j++) { 
            if (arr[j] > arr[j+1]) {  
                swap(&arr[j], &arr[j]);
            }
        }
    }
}
```

---

## 2.2 选择排序

时间复杂度 $$O(N^2)$$

``` cpp
void select_sort(int A[], int n) {
    int min;
    for(int i=0; i<n-1; i++) {
        min = i; 
        for(int j=i+1; j<n; j++) {
            if(A[min] > A[j]) {
                min = j;
            }
        }
        // 将最小值与到本次循环的首元素交换
        swap(&A[min], &A[i]);
    }
}
```

---

## 2.3 插入排序

时间复杂度 $$O(N^2)$$

``` cpp
void insert_sort(int arr[], int n) {
    int j, temp;
    for(int i=1; i<n; i++) {
        temp = arr[i];
        for(j=i; j>0 && arr[j-1]>temp; j--) {
            arr[j] = arr[j-1];
        }
        arr[j] = temp;
    }
}
```

---

## 2.4 归并排序

时间复杂度 $$O(N*log^N)$$

``` cpp
void merge(int arr[],int temp[], int start, int mid, int end) {
    int i=start, j=mid+1, k=start;
    while(i!=mid+1 && j!=end+1) {
        if(arr[i] > arr[j])  
            temp[k++] = arr[j++];
        else  
            temp[k++] = arr[i++];
    }
    while(i != mid+1)  
        temp[k++] = arr[i++];
    while(j != end+1)  
        temp[k++] = arr[j++];
    for(i=start; i<=end; i++)
        arr[i] = temp[i];
}
 
void merge_sort(int arr[], int temp[], int start, int end) {
    if(start >= end)
        return;

    int mid = start + (end-start) / 2; // 避免溢出
    merge_sort(arr, temp, start, mid);
    merge_sort(arr, temp, mid+1, end);
    merge(arr, temp, start, mid, end);
}

void merge_sort(int arr[], int len) {
    int * temp = (int *)malloc(sizeof(int) * len);
    merge_sort(arr, temp, 0, len-1);
    free(temp);
}
```

### 2.4.1 递归的时间复杂度

**master公式**
$$
T(N) = a * T(\frac{N}{b}) + O(N^d)
$$

- $$N$$ ： 数据样本量
- $$a$$ ： 子过程调用次数
- $$\frac{N}{b}$$ ： 子过程数据样本量
- $$O(N^d)$$ ： 除去递归之外的时间复杂度

$$
递归时间复杂度 = 
\begin{cases}  
	O(N^{log_b^a}) , &log_b^a>d \\
	O(N^{d*log^N}) , &log_b^a=d \\
	O(N^d) , &log_b^a<d
\end{cases}
$$



### 2.4.2 数组小和问题

> 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

例：[2, 3, 4, 1, 5] 小和为17。

- 2左边比其小的数：
- 3左边比其小的数：2
- 4左边比其小的数：2、 3
- 1左边比其小的数：
- 5左边比其小的数：2、 3、 4、 1

思路：求数组中每个数左侧比其小的所有数的和，等同于求每个数右侧比其大的数的数量乘以这个数的和进行累加。

### 2.4.3 逆序对问题

> 在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对。

### 2.4.4 瑞士轮问题

> 在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。
>
> 本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折衷，既保证了比赛的稳定性，又能使赛程不至于过长。
>
> $$2*N$$ 名编号为 $$1$$~$$2N$$ 的选手共进行 $$R$$ 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会对选手进行一次排名。排名的依据是选手的总分。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。
>
> 每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1名和第2名、第3名和第4名、……、第$$2K – 1$$名和第$$2K$$名、…… 、第$$2N – 1$$名和第$$2N$$名，各进行一场比赛。每场比赛胜者得1分，负者得0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。
> 
> 现给定每个选手的初始分数及其实力值，试计算在 $$R$$ 轮比赛过后，排名第 $$Q$$ 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。

---

## 2.5 快速排序

时间复杂度 $$O(N*log^N)$$

### 2.5.1 标准快排

``` cpp
标准快排代码
```

### 2.5.2 分类问题

时间复杂度 $$O(N)$$

> 给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。

指针p从-1位置开始，规划p左侧为小于num的数的区域，然后准备一个指针q指向下标0位置，如果q指向元素小于等于num，则q指向元素与p+1指向元素交换，p、q往后移动；如果q指向元素大于num，则q往后移动，直到q移出数组

### 2.5.3 荷兰国旗问题

时间复杂度 $$O(N)$$

> 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。

## 2.6 堆排序

时间复杂度 $$O(N*log^N)$$

``` cpp
堆排代码
```

### 2.6.1 两种建堆方法

- 第一种方法 HeapInsert

假定事先不知道有多少个元素，通过不断往堆里面插入元素进行调整来构建堆。大致步骤如下：

1. 首先增加堆的长度，在最末尾的地方加入最新插入的元素。
2. 比较当前元素和它的父结点值，如果比父结点值大，则交换两个元素，否则返回。
3. 重复步骤2。

这种插入建堆的时间复杂度是 $$O(N*log^N)$$

- 第二种方法 Heapify

从最后一个非叶子节点一直到根结点进行堆化的调整。如果当前节点小于某个自己的孩子节点（大根堆中），那么当前节点和这个孩子交换。Heapify是一种类似下沉的操作，HeapInsert是一种类似上浮的操作。

这种建堆的时间复杂度是 $$O(N)$$

怎么找到第一个非叶子节点?

如果根节点在数组中的索引为0，那么第一个非叶子节点的计算公式为: $$last\_non\_leav = (arr.length - 2)/2$$

可以设最后一个非叶子节点位置为x，那么最后一个叶子节点一定是$$(2x+1)$$ 或者$$(2x+2)$$中的一个，然后可以建立方程求解。

---

## 2.7 桶排序

**桶排序(Bucket sort)**或所谓的**箱排序**，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。

``` cpp
桶排序
```
### 2.7.1 相邻元素最大差值

> 给定一个数组，求如果排序之后，相邻两数的最大差值，要求时间复杂度$$O(N)$$，且要求不能用非基于比较的排序。

---

## 2.8 计数排序



### 2.8.1 分布计数排序

**分布计数排序**是一种非比较性质的排序算法，元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。**分布计数排序**过程中不存在元素之间的比较和交换操作，根据元素本身的值，将每个元素出现的次数记录到辅助空间后，通过对辅助空间内数据的计算，即可确定每一个元素最终的位置。

算法过程：

1. 根据待排序集合中最大元素和最小元素的差值范围，申请额外空间；
2. 遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内；
3. 对额外空间内数据进行计算，得出每一个元素的正确位置；
4. 将待排序集合每一个元素移动到计算得出的正确位置上。

### 2.8.2 比较计数排序

**比较计数排序**的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。

例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。

``` cpp
计数排序代码
```
---

## 2.9 基数排序

``` cpp
基数排序代码
```

---

