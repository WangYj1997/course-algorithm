{"./":{"url":"./","title":"介绍","keywords":"","body":"算法分析与设计 章节 章节 名称 第一章 算法概述 第二章 排序算法 第三章 搜索算法 Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-09-01 14:01:06 "},"slides/ch01.html":{"url":"slides/ch01.html","title":"第一章：算法概述","keywords":"","body":"第1章 算法概述 1.1 引言 算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。 也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。 同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。 一个算法的评价主要从时间复杂度和空间复杂度来考虑。 一个算法应该具有以下五个重要的特征： 有穷性 --- 执行有限条指令后一定要终止。 确定性(无二义) --- 算法的每一步操作都必须有确切定义，不得有任何歧义性。 可(能)行性 --- 算法的每一步操作都必须是可行的，即每步操作均能在有限时间内完成。 输入 --- 一个算法有n(n>=0)个初始数据的输入。 输出 --- 一个算法有一个或多个与输入有某种关系的有效信息的输出。 1.2 时间复杂度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。 我们把问题的规模称之为 n ，例如排序问题中 n 为排序元素个数、图的问题中 n 是图的顶点数、矩阵中的 n 为矩阵的阶数等，当 n 不断变化时，花费时间也会不断变化，当我们想知道它变化时呈现什么规律时，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模 n 的某个函数f(n)，算法的时间度量记作 \r T(n) = O(f(n))\r 表示随着问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。 1.3 时间复杂度推导原则 如果运行时间是常数量级，用常数1表示； 只保留时间函数中的最高阶项； 如果最高阶项存在，则省去最高阶项前面的系数。 1.4 例题 问题：一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M。 算法1：对于数组B中的每一个数，都在A中通过遍历的方式找一下。 算法2：对于数组B中的每一个数，都在A中通过二分的方式找一下。 算法3：先把数组B排序，然后用类似外排的方式打印所有不在A中出现的数。 时间复杂度： 算法1时间复杂度：O(M*N) 算法2时间复杂度：O(M*\\log_2^N) 算法3时间复杂度：O(M*\\log_2^M + M + N) 对数组A中M个数排序时间复杂度：O(M*\\log_2^M) 类似于外派方式打印不在数组A中的数时间复杂度：O(M+N) 例如：A[1, 3, 4, 5, 6]、B[8, 2, 5, 3]，B排序后变为[2, 3, 5, 8]。 i ↓ A: 1 3 4 5 6 B: 2 3 5 8 ↑ j for(i=0,j=0; i=A.length) 打印B[j]后面所有元素; Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-09-01 14:20:14 "},"slides/ch02.html":{"url":"slides/ch02.html","title":"第二章：排序算法","keywords":"","body":"第2章 排序算法 2.1 冒泡排序 时间复杂度 O(N^2) void bubble_sort (int arr[], int len) { for (int i=0; i arr[j+1]) { swap(&arr[j], &arr[j]); } } } } 2.2 选择排序 时间复杂度 O(N^2) void select_sort(int A[], int n) { int min; for(int i=0; i A[j]) { min = j; } } // 将最小值与到本次循环的首元素交换 swap(&A[min], &A[i]); } } 2.3 插入排序 时间复杂度 O(N^2) void insert_sort(int arr[], int n) { int j, temp; for(int i=1; i0 && arr[j-1]>temp; j--) { arr[j] = arr[j-1]; } arr[j] = temp; } } 2.4 归并排序 时间复杂度 O(N*log^N) void merge(int arr[],int temp[], int start, int mid, int end) { int i=start, j=mid+1, k=start; while(i!=mid+1 && j!=end+1) { if(arr[i] > arr[j]) temp[k++] = arr[j++]; else temp[k++] = arr[i++]; } while(i != mid+1) temp[k++] = arr[i++]; while(j != end+1) temp[k++] = arr[j++]; for(i=start; i= end) return; int mid = start + (end-start) / 2; // 避免溢出 merge_sort(arr, temp, start, mid); merge_sort(arr, temp, mid+1, end); merge(arr, temp, start, mid, end); } void merge_sort(int arr[], int len) { int * temp = (int *)malloc(sizeof(int) * len); merge_sort(arr, temp, 0, len-1); free(temp); } 2.4.1 递归的时间复杂度 master公式 \r T(N) = a * T(\\frac{N}{b}) + O(N^d)\r N ： 数据样本量 a ： 子过程调用次数 \\frac{N}{b} ： 子过程数据样本量 O(N^d) ： 除去递归之外的时间复杂度 \r 递归时间复杂度 = \r \\begin{cases} \r \tO(N^{log_b^a}) , &log_b^a>d \\\\\r \tO(N^{d*log^N}) , &log_b^a=d \\\\\r \tO(N^d) , &log_b^a 2.4.2 数组小和问题 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。 例：[2, 3, 4, 1, 5] 小和为17。 2左边比其小的数： 3左边比其小的数：2 4左边比其小的数：2、 3 1左边比其小的数： 5左边比其小的数：2、 3、 4、 1 思路：求数组中每个数左侧比其小的所有数的和，等同于求每个数右侧比其大的数的数量乘以这个数的和进行累加。 2.4.3 逆序对问题 在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对。 2.4.4 瑞士轮问题 在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。 本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折衷，既保证了比赛的稳定性，又能使赛程不至于过长。 2*N 名编号为 1~2N 的选手共进行 R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会对选手进行一次排名。排名的依据是选手的总分。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。 每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1名和第2名、第3名和第4名、……、第2K – 1名和第2K名、…… 、第2N – 1名和第2N名，各进行一场比赛。每场比赛胜者得1分，负者得0分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。 现给定每个选手的初始分数及其实力值，试计算在 R 轮比赛过后，排名第 Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。 2.5 快速排序 时间复杂度 O(N*log^N) 2.5.1 标准快排 标准快排代码 2.5.2 分类问题 时间复杂度 O(N) 给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。 指针p从-1位置开始，规划p左侧为小于num的数的区域，然后准备一个指针q指向下标0位置，如果q指向元素小于等于num，则q指向元素与p+1指向元素交换，p、q往后移动；如果q指向元素大于num，则q往后移动，直到q移出数组 2.5.3 荷兰国旗问题 时间复杂度 O(N) 给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。 2.6 堆排序 时间复杂度 O(N*log^N) 堆排代码 2.6.1 两种建堆方法 第一种方法 HeapInsert 假定事先不知道有多少个元素，通过不断往堆里面插入元素进行调整来构建堆。大致步骤如下： 首先增加堆的长度，在最末尾的地方加入最新插入的元素。 比较当前元素和它的父结点值，如果比父结点值大，则交换两个元素，否则返回。 重复步骤2。 这种插入建堆的时间复杂度是 O(N*log^N) 第二种方法 Heapify 从最后一个非叶子节点一直到根结点进行堆化的调整。如果当前节点小于某个自己的孩子节点（大根堆中），那么当前节点和这个孩子交换。Heapify是一种类似下沉的操作，HeapInsert是一种类似上浮的操作。 这种建堆的时间复杂度是 O(N) 怎么找到第一个非叶子节点? 如果根节点在数组中的索引为0，那么第一个非叶子节点的计算公式为: last\\_non\\_leav = (arr.length - 2)/2 可以设最后一个非叶子节点位置为x，那么最后一个叶子节点一定是(2x+1) 或者(2x+2)中的一个，然后可以建立方程求解。 2.7 桶排序 桶排序(Bucket sort)或所谓的箱排序，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。 桶排序 2.7.1 相邻元素最大差值 给定一个数组，求如果排序之后，相邻两数的最大差值，要求时间复杂度O(N)，且要求不能用非基于比较的排序。 2.8 计数排序 2.8.1 分布计数排序 分布计数排序是一种非比较性质的排序算法，元素从未排序状态变为已排序状态的过程，是由额外空间的辅助和元素本身的值决定的。分布计数排序过程中不存在元素之间的比较和交换操作，根据元素本身的值，将每个元素出现的次数记录到辅助空间后，通过对辅助空间内数据的计算，即可确定每一个元素最终的位置。 算法过程： 根据待排序集合中最大元素和最小元素的差值范围，申请额外空间； 遍历待排序集合，将每一个元素出现的次数记录到元素值对应的额外空间内； 对额外空间内数据进行计算，得出每一个元素的正确位置； 将待排序集合每一个元素移动到计算得出的正确位置上。 2.8.2 比较计数排序 比较计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。 例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。 计数排序代码 2.9 基数排序 基数排序代码 Copyright © eetze 2019 all right reserved，powered by GitbookFile Modify: 2019-09-01 14:24:48 "}}